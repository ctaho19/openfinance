{"version":3,"file":"pay-periods_BQe5dfMu.mjs","sources":["../../../src/lib/services/pay-periods.ts"],"sourcesContent":["import { prisma } from \"@/lib/db\";\nimport type { BillPayment, Bill } from \"@prisma/client\";\n\nexport {\n  getCurrentPayPeriod,\n  getNextPayPeriod,\n  getPreviousPayPeriod,\n  getPayPeriodForDate,\n  getPayPeriods,\n  isDateInPayPeriod,\n  formatPayPeriod,\n  getDueDatesInPeriod,\n  type PayPeriod,\n} from \"@/lib/pay-periods\";\n\nexport type PaymentWithBill = BillPayment & {\n  bill: Bill & {\n    debt: { id: string; name: string; type: string; status: string } | null;\n  };\n};\n\nexport interface MarkPaymentResult {\n  payment: BillPayment;\n  debtUpdated: boolean;\n}\n\nexport async function getPaymentsForPeriod(\n  userId: string,\n  startDate: Date,\n  endDate: Date\n): Promise<PaymentWithBill[]> {\n  return prisma.billPayment.findMany({\n    where: {\n      bill: {\n        userId,\n        OR: [\n          { debtId: null },\n          {\n            debt: {\n              OR: [\n                { status: { not: \"DEFERRED\" } },\n                { deferredUntil: null },\n                { deferredUntil: { lte: endDate } },\n              ],\n            },\n          },\n        ],\n      },\n      dueDate: {\n        gte: startDate,\n        lte: endDate,\n      },\n    },\n    include: {\n      bill: {\n        include: {\n          debt: {\n            select: { id: true, name: true, type: true, status: true },\n          },\n        },\n      },\n    },\n    orderBy: { dueDate: \"asc\" },\n  });\n}\n\nexport async function markPaymentPaid(\n  userId: string,\n  paymentId: string\n): Promise<MarkPaymentResult> {\n  const payment = await prisma.billPayment.findFirst({\n    where: { id: paymentId },\n    include: {\n      bill: {\n        include: { debt: true },\n      },\n    },\n  });\n\n  if (!payment) {\n    throw new Error(\"Payment not found\");\n  }\n\n  if (payment.bill.userId !== userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const paidAt = new Date();\n  let debtUpdated = false;\n\n  const result = await prisma.$transaction(async (tx) => {\n    const updatedPayment = await tx.billPayment.update({\n      where: { id: paymentId },\n      data: {\n        status: \"PAID\",\n        paidAt,\n      },\n    });\n\n    if (payment.bill.debtId && payment.bill.debt) {\n      const debt = payment.bill.debt;\n      const paymentAmount = Number(payment.amount);\n      const interestRate = Number(debt.interestRate);\n      const currentBalance = Number(debt.currentBalance);\n\n      let interest = 0;\n      let principal = paymentAmount;\n\n      if (debt.type !== \"BNPL\" && interestRate > 0) {\n        const monthlyRate = interestRate / 100 / 12;\n        interest = Math.min(currentBalance * monthlyRate, paymentAmount);\n        principal = paymentAmount - interest;\n      }\n\n      const newBalance = Math.max(0, currentBalance - principal);\n\n      await tx.debtPayment.create({\n        data: {\n          debtId: debt.id,\n          date: paidAt,\n          amount: paymentAmount,\n          principal,\n          interest,\n          newBalance,\n          notes: `Auto-logged from bill payment: ${payment.bill.name}`,\n        },\n      });\n\n      await tx.debt.update({\n        where: { id: debt.id },\n        data: { currentBalance: newBalance },\n      });\n\n      if (debt.type === \"BNPL\") {\n        const scheduledPayment = await tx.scheduledPayment.findFirst({\n          where: {\n            debtId: debt.id,\n            isPaid: false,\n            dueDate: {\n              gte: new Date(payment.dueDate.getTime() - 24 * 60 * 60 * 1000),\n              lte: new Date(payment.dueDate.getTime() + 24 * 60 * 60 * 1000),\n            },\n          },\n        });\n\n        if (scheduledPayment) {\n          await tx.scheduledPayment.update({\n            where: { id: scheduledPayment.id },\n            data: {\n              isPaid: true,\n              paidAt,\n              paidAmount: paymentAmount,\n            },\n          });\n        }\n      }\n\n      debtUpdated = true;\n    }\n\n    return updatedPayment;\n  });\n\n  return { payment: result, debtUpdated };\n}\n\nexport async function markPaymentUnpaid(\n  userId: string,\n  paymentId: string\n): Promise<BillPayment> {\n  const payment = await prisma.billPayment.findFirst({\n    where: { id: paymentId },\n    include: {\n      bill: true,\n    },\n  });\n\n  if (!payment) {\n    throw new Error(\"Payment not found\");\n  }\n\n  if (payment.bill.userId !== userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  return prisma.billPayment.update({\n    where: { id: paymentId },\n    data: {\n      status: \"UNPAID\",\n      paidAt: null,\n    },\n  });\n}\n\n// Known BNPL lender keywords for canonical name extraction\nconst LENDER_KEYWORDS: { key: string; label: string }[] = [\n  { key: \"affirm\", label: \"Affirm\" },\n  { key: \"afterpay\", label: \"Afterpay\" },\n  { key: \"klarna\", label: \"Klarna\" },\n  { key: \"sezzle\", label: \"Sezzle\" },\n  { key: \"zip\", label: \"Zip\" },\n  { key: \"paypal\", label: \"PayPal Pay Later\" },\n  { key: \"apple pay later\", label: \"Apple Pay Later\" },\n  { key: \"quadpay\", label: \"Zip\" }, // QuadPay rebranded to Zip\n  { key: \"splitit\", label: \"Splitit\" },\n  { key: \"perpay\", label: \"Perpay\" },\n];\n\n/**\n * Extract canonical lender name from a debt/bill name string\n */\nexport function extractLenderName(raw: string): string {\n  const lower = raw.toLowerCase();\n\n  // 1) Keyword-based canonicalization\n  for (const { key, label } of LENDER_KEYWORDS) {\n    if (lower.includes(key)) return label;\n  }\n\n  // 2) Fallback: prefix before separators (\"Affirm - 4 payments left\")\n  const separatorMatch = raw.split(/[-–—(]/)[0];\n  const trimmed = separatorMatch?.trim();\n\n  // 3) Final fallback: return trimmed or raw\n  return trimmed || raw;\n}\n\n/**\n * Get lender name from a payment with bill/debt info\n */\nexport function getLenderNameFromPayment(payment: PaymentWithBill): string {\n  const sourceName = payment.bill.debt?.name ?? payment.bill.name;\n  return extractLenderName(sourceName);\n}\n\nexport async function getPaymentStatus(\n  userId: string,\n  paymentId: string\n): Promise<string> {\n  const payment = await prisma.billPayment.findFirst({\n    where: { id: paymentId },\n    include: {\n      bill: { select: { userId: true } },\n    },\n  });\n\n  if (!payment) {\n    throw new Error(\"Payment not found\");\n  }\n\n  if (payment.bill.userId !== userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  return payment.status;\n}\n"],"names":[],"mappings":"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"}